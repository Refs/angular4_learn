世界三大MOOC网站： Coursera、Udacity（有免费的D3可学）、edX 去找你需要的课程吧，小伙子

# 组件间通

![组件间通讯](../images/component_communication.png)

* angular的应用的核心就是组件，任何一个angular程序在本质上都是一个组件树，如图中所示 1号组件是整个组件树的‘根’ 一般就是我们的appComponent 其包含 2、3、6三个子组件，2号组件又包含4、5两个子组件，在设计一个组件时我们需要确保组件之间是‘松耦合’的，也就是说‘组件之间互相知道的越少越好’ 因为松耦合的组件 重用性才高；
* 假设我们点击组件4 模板里面的一个按钮的时候，应该触发组件5的一段初始化逻辑，按照传统的做法我们会在组件4的按钮点击事件里，调用组件5的一个方法，但是如果我们这样做 则组件4与组件5就会紧密的耦合在一起； 那么有没有可能在组件4不知道组件5存在的情况下，实现上面的需求
* 在之前我们学会使用 “依赖注入” 来实现“松耦合的组件” ，但是光有依赖注入是不够的，在这一章里我们将学习如何使用一种 松耦合 的方式 在组件之间来传递数据，是我们可以开发出 高重用性的组件，

## 组件的输入输出属性

> 黑盒模型、输入属性、输出属性、订阅

* 游戏机本身就是一个黑盒模型，我们看不到游戏机内部是如何去运转的，游戏机值暴露两个手柄给我们，而游戏机并不关心谁来操作这两个手柄，游戏机只关心一件事情 就是如果你按了a建，屏幕上应该去显示什么；就像它不关心谁在按手柄给其输入信息一样，它也不关心谁在看它的屏幕输出，甚至有没有看都无所谓，外面是一条狗还是一个人在玩游戏机，对游戏机来说是没有区别的，它只是规定好输入的格式（两个手柄），然后去输出外面可能会感兴趣的东西；
* 我们的组件就要设计成这样的黑盒模型，如果一个组件要从外部世界去接受一些东西，那么他应该使用输入属性声明它需要的东西，至于这些东西从哪里来，组件不需要知道，组件只需要知道 当这些它需要的东西 外部世界提供给它之后，它应该怎么去做；
* 同样一个组件想要将一些外部世界可能感兴趣的东西告诉外部世界，其应该通过其“输出属性”来发射事件，至于这些事件发射给谁，组件也不需要去知道
* 那些对组件发射东西感兴趣的东西，应该自己来“订阅”组件发射的事件

### 组件的输入属性

组件的输入属性指的是用@input()装饰器注解的属性<注意首先其是一个property，输入知识一个修饰>，用来从父组件接受数据；

使用场景：在父组件中输一个我想买的股票的名字，通过输入属性将股票的名字传递给子组件，然后在子组件中显示出来

影响时单向的：父组件的值改变时，会影响子组件，子组件的值改变的时候 不会反过来影响父组件，

#### 两种向组件传递数据方式的对比：

到现在为止，我们已经讲了两种向组件传递数据的方式，一种时刚才看到的输入属性，还有一种时路由参数我们来对比一下这两种：

* 输入属性时通过`属性` 来传递数据的，并且这种传递只能在有父子关系的组件之间，由父组件向子组件来传递数据，

```html
<div>我是父组件</div>
<div>
  <input [(ngModel)]="stock">
  <!-- 在组件的模板中引用另一个组件的时候，他们两个实际上形成了一个父子关系，这个时候才能同组输入属性从父组件给子组件传递数据 -->
  <app-order [stockCode]="stock" [amonut]="100" ></app-order>
</div>

```

* 路由参数是通过构造函数来传递数据的，

```ts
export class OrderComponent implements OnInit {
  @Input()
  stockCode: string;
  @Input()
  amonut: number;
  // 在构造函数里面依赖注入一个ActivatedRoute类型的一个对象，然后通过这样一个对象的‘参数订阅’或者‘参数快照’外面传入的参数
  constructor(routeInfo: ActivatedRoute) { }

  ngOnInit() {
  }

}

```

 
## 使用中间人模式传递数据

介绍中间人模式以及实现中间人模式，以便在没有父子关系的组件之间传递数据

## 组件生命周期以及angular的变化发现机制

世界三大MOOC网站： Coursera、Udacity、edX 去找你需要的课程吧，小伙子
